#!/usr/bin/env python3
"""
Generate requirements.txt by combining pipreqs output with actual installed versions.

This script processes files created by generate_requirements.sh:
1. Reads reqs_from_pipreqs.txt (created by pipreqs)
2. Reads reqs_from_pipfreeze.txt (created by pip freeze)
3. Combines them to create a requirements.txt with correct versions
"""

import os
import re

def read_requirements_file(filename):
    """Read requirements file and return dict of package -> version."""
    requirements = {}
    if not os.path.exists(filename):
        print(f"⚠️  Warning: {filename} not found")
        return requirements
    
    with open(filename, 'r') as f:
        for line in f:
            line = line.strip()
            if line and not line.startswith('#'):
                # Handle different formats: package==version, package>=version, etc.
                match = re.match(r'^([a-zA-Z0-9_-]+)\s*([=<>!~].*)?$', line)
                if match:
                    package = match.group(1).lower()
                    version = match.group(2) if match.group(2) else ''
                    requirements[package] = version
    return requirements

def main():
    print("🔧 Processing requirements files...")
    
    # Step 1: Read both files
    print("\n1️⃣  Reading generated files...")
    pipreqs_packages = read_requirements_file("reqs_from_pipreqs.txt")
    pipfreeze_packages = read_requirements_file("reqs_from_pipfreeze.txt")
    
    print(f"   Found {len(pipreqs_packages)} packages from pipreqs")
    print(f"   Found {len(pipfreeze_packages)} packages from pip freeze")
    
    # Step 2: Replace versions
    print("\n2️⃣  Combining package lists with correct versions...")
    final_requirements = []
    missing_packages = []
    
    for package, _ in pipreqs_packages.items():
        if package in pipfreeze_packages:
            version = pipfreeze_packages[package]
            if version:
                final_requirements.append(f"{package}{version}")
            else:
                final_requirements.append(package)
        else:
            missing_packages.append(package)
            # Keep the original version from pipreqs if available
            original_version = pipreqs_packages[package]
            if original_version:
                final_requirements.append(f"{package}{original_version}")
            else:
                final_requirements.append(package)
    
    # Step 3: Write new requirements.txt
    print("\n3️⃣  Writing new requirements.txt...")
    with open("requirements.txt", "w") as f:
        f.write("# Generated by generate_requirements.sh + generate_requirements.py\n")
        f.write("# Combines pipreqs output with actual installed versions\n\n")
        for req in sorted(final_requirements):
            # Custom change 1: Change "unstructured" to "unstructured[all-docs]" but keep version
            if req.startswith("unstructured=="):
                # Extract version from original requirement
                version = req.replace("unstructured==", "")
                f.write(f"unstructured[all-docs]=={version}\n")
            else:
                f.write(f"{req}\n")
        
        # Custom change 2: Add pdfminer.six package
        f.write("pdfminer.six==20231228\n")
    
    print(f"✓ Successfully created requirements.txt with {len(final_requirements)} packages")
    
    # Summary
    print("\n📊 Summary:")
    print(f"   • Total packages: {len(final_requirements)}")
    if missing_packages:
        print(f"   • Packages not found in pip freeze: {len(missing_packages)}")
        print(f"     {', '.join(missing_packages[:5])}{'...' if len(missing_packages) > 5 else ''}")
    else:
        print("   • All packages found with correct versions")
    
    # Cleanup temporary files
    
    print("\n🧹 Cleaning up temporary files...")
    for temp_file in ["reqs_from_pipreqs.txt", "reqs_from_pipfreeze.txt"]:
        if os.path.exists(temp_file):
            os.remove(temp_file)
            print(f"   Removed {temp_file}")
    
    print("\n✅ Done! Check requirements.txt for the final result.")

if __name__ == "__main__":
    main()